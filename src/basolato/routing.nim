import json, strformat, options, strutils, macros, re
import asyncdispatch
# framework
import
  base, response, logger, middleware, resources/errorPage, resources/ddPage,
  header
from controller import redirect, render, errorRedirect
# 3rd party
import ./core/core

# framework
export base, response, middleware, redirect, render, errorRedirect
# 3rd party
# export core except redirect, setCookie, resp
export core


template route*(responseArg: Response) =
  block:
    let response = responseArg
    var headers = response.headers
    case response.responseType:
    of String:
      if not headers.hasKey("Content-Type"):
        headers.add(("Content-Type", "text/html;charset=utf-8"))
    of Json:
      if not headers.hasKey("Content-Type"):
        headers.add(("Content-Type", "application/json;charset=utf-8"))
      response.bodyString = $(response.bodyJson)
    of Redirect:
      logger($response.status &
        &"  {request.ip}  {request.reqMethod}  {request.path}")
      headers.add(("Location", response.url))
      resp response.status, headers, ""

    if response.status == Http200:
      logger($response.status &
        &"  {request.ip}  {request.reqMethod}  {request.path}")
      logger($headers)
    elif response.status.is4xx() or response.status.is5xx():
      echoErrorMsg($request.params)
      echoErrorMsg($response.status &
        &"  {request.ip}  {request.reqMethod}  {request.path}")
      echoErrorMsg($headers)
    resp response.status, headers, response.bodyString

proc joinHeader(headers:openArray[Headers]): Headers =
  ## join seq and children tuple if each headers have same key in child tuple
  ##
  ## .. code-block:: nim
  ##    let t1 = @[("key1", "val1"),("key2", "val2")]
  ##    let t2 = @[("key1", "val1++"),("key3", "val3")]
  ##    let t3 = joinHeader([t1, t2])
  ##
  ##    echo t3
  ##    >> @[
  ##      ("key1", "val1, val1++"),
  ##      ("key2", "val2"),
  ##      ("key3", "val3"),
  ##    ]
  ##
  var newHeader: Headers
  var tmp = result.toTable
  for header in headers:
    let headerTable = header.toOrderedTable
    for key, value in headerTable.pairs:
      if tmp.hasKey(key):
        tmp[key] = [tmp[key], headerTable[key]].join(", ")
      else:
        tmp[key] = headerTable[key]
  for key, val in tmp.pairs:
    newHeader.add(
      (key:key, val:val)
    )
  return newHeader


template route*(responseArg:Response,
                headersArg:openArray[Headers]) =
  block:
    let response = responseArg
    var headersMiddleware = @headersArg
    var newHeaders: Headers
    headersMiddleware.add(response.headers) # headerMiddleware + headerController
    newHeaders = joinHeader(headersMiddleware)
    case response.responseType:
    of String:
      newHeaders.add(("Content-Type", "text/html;charset=utf-8"))
    of Json:
      newHeaders.add(("Content-Type", "application/json"))
      response.bodyString = $(response.bodyJson)
    of Redirect:
      logger($response.status &
        &"  {request.ip}  {request.reqMethod}  {request.path}")
      newHeaders.add(("Location", response.url))
      resp response.status, newHeaders, ""

    if response.status == Http200:
      logger($response.status &
        &"  {request.ip}  {request.reqMethod}  {request.path}")
      logger($newHeaders)
    elif response.status.is4xx() or response.status.is5xx():
      echoErrorMsg($response.status &
        &"  {request.ip}  {request.reqMethod}  {request.path}")
      echoErrorMsg($newHeaders)
    resp response.status, newHeaders, response.bodyString


macro createHttpCodeError():untyped =
  var strBody = ""
  for num in errorStatusArray:
    strBody.add(fmt"""
of "Error{num.repr}":
  return Http{num.repr}
""")
  return parseStmt(fmt"""
case $exception.name
{strBody}
else:
  return Http500
""")

proc checkHttpCode(exception:ref Exception):HttpCode =
  ## Generated by macro createHttpCodeError.
  ## List is httpCodeArray
  ## .. code-block:: nim
  ##   case $exception.name
  ##   of Error505:
  ##     return Http505
  ##   of Error504:
  ##     return Http504
  ##   of Error503:
  ##     return Http503
  ##   .
  ##   .
  createHttpCodeError


template exceptionRoute*(pagePath="") =
  defer: GCunref exception

  if exception.name == "ErrorAuthRedirect".cstring:
    var cookie = newCookie(request)
    cookie.delete("session_id")
    route(errorRedirect(exception.msg).setCookie(cookie))

  if exception.name == "DD".cstring:
    var msg = exception.msg
    msg = msg.replace(re"Async traceback:[.\s\S]*")
    route(render(Http200, ddPage(msg)))

  let status = checkHttpCode(exception)
  if status.is4xx() or status.is5xx():
    echoErrorMsg($request.params)
    echoErrorMsg($status &
      &"  {request.reqMethod}  {request.ip}  {request.path}  {exception.msg}")
    if pagePath == "":
      if exception.msg == "Invalid session id":
        var cookie = newCookie(request)
        cookie.delete("session_id")
        route(render(status, errorPage(status, exception.msg)).setCookie(cookie))
      else:
        route(render(status, errorPage(status, exception.msg)))
    else:
      route(render(status, html(pagePath)))
  else:
    route(errorRedirect(exception.msg))


template http404Route*(pagePath="") =
  if not request.path.contains("favicon"):
    echoErrorMsg(&"{$Http404}  {request.ip}  {request.path}")
  if pagePath == "":
    route(render(Http404, errorPage(Http404, "route not match")))
  else:
    route(render(Http404, html(pagePath)))


template middleware*(procs:varargs[Response]) =
  for p in procs:
    if p == nil:
      # echo getCurrentExceptionMsg()
      discard
    else:
      route(p)
      break
